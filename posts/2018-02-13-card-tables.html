<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <!-- <link href="https://fonts.googleapis.com/css?family=Roboto|Inconsolata|Work+Sans|Droid+Serif" rel="stylesheet"> -->
    <style>@font-face{font-family:'DroidSerif';font-style:normal;font-weight:400;src:local('DroidSerifRegular'),local('DroidSerif-Regular'),url(https://fonts.gstatic.com/s/droidserif/v8/tDbI2oqRg1oM3QBjjcaDkOr9rAA.ttf)format('truetype');}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;src:local('InconsolataRegular'),local('Inconsolata-Regular'),url(https://fonts.gstatic.com/s/inconsolata/v16/QldKNThLqRwH-OJ1UHjlKGlZ5q0.ttf)format('truetype');}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:local('Roboto'),local('Roboto-Regular'),url(https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxP.ttf)format('truetype');}@font-face{font-family:'WorkSans';font-style:normal;font-weight:400;src:local('WorkSans'),local('WorkSans-Regular'),url(https://fonts.gstatic.com/s/worksans/v3/QGYsz_wNahGAdqQ43Rh_fKDs.ttf)format('truetype');}</style>
    <!-- <link href="/css/text.css" rel="stylesheet" type="text/css"> -->
    <style>#header h1 { font-size: 120%; display: inline-block; } .sourceCode { overflow-x: scroll; } code, pre { color: #000; background-color: #fff; font-weight: normal; font-family: "Menlo", "Consolas", "Inconsolata", "Anonymous", "Monaco", monospace; font-size: 0.9em; line-height: 1.2em; } p code, li>code { border: 1px solid #DDDDDD; padding: 2px; font-size: 0.8em; } #header h1 a, h2.post-title a, h2.static-title a { color: #000; } ul, ol { margin-left: 2em; } div.highlight, pre { margin-bottom: 1em; } code.has-jax { border: none; background-color: #fff; } .date { font-style: italic; color: #4e4e4e; } body { font: 300 1.1em/1.6em Georgia, "Droid Serif", "Open Sans", "DejaVu Serif", serif; } blockquote { padding-top: 0; } .panel { padding-left: 2em; padding-right: 2em; font-size: 120%; } .panel p { font-weight: bold; font-style: italic; line-height: 1.1em; } footer { text-align: center; } footer span { font-style: italic; } footer { padding-top: 2em; } /* Generated by pandoc. */ table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; } td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; } td.sourceCode { padding-left: 5px; } .sourceCode span.kw { color: #007020; font-weight: bold; } .sourceCode span.dt { color: #902000; } .sourceCode span.dv { color: #40a070; } .sourceCode span.bn { color: #40a070; } .sourceCode span.fl { color: #40a070; } .sourceCode span.ch { color: #4070a0; } .sourceCode span.st { color: #4070a0; } .sourceCode span.co { color: #60a0b0; font-style: italic; } .sourceCode span.ot { color: #007020; } .sourceCode span.al { color: red; font-weight: bold; } .sourceCode span.fu { color: #06287e; } .sourceCode span.re { } .sourceCode span.er { color: red; font-weight: bold; }</style>
    <!-- <link href="/css/aduffy.css" rel="stylesheet" type="text/css"> -->
    <style>/* Modify selection color on WebKit/Mozilla. */ ::-moz-selection { background: antiquewhite; } ::selection { background: antiquewhite; } body { padding-bottom: 30px; }</style>
    
    <title>JVM Garbage collection; or WTF is a Card Table? • aduffy.io</title>
    
  </head>
  <body>
    <div class="row">
        <div id="header" class="large-10 large-offset-1 columns">
            <h1><a href="../">aduffy.io</a>://</h1>
            <a href="../">posts</a>
            /
            <a href="../about.html">about</a>
            /
            <a href="../projects.html">projects</a>
            /
            <a href="../photos.html">photos</a>
            &mdash;
            <span><a class="underline" href="https://github.com/a10y/a10y.github.io/commit/5fb2127
">5fb2127
</a></span>
        </div>
    </div>
    <div class="row">
      <div class="large-10 large-centered columns">
        
        <h1>JVM Garbage collection; or WTF is a Card Table?</h1>
        
        <p class="date">13 Feb 2018</p>

<p>I find the JVM a really fascinating piece of technology (not least of all because I spend a lot of time working with/against it). The folks from Sun and subsequently Oracle Labs are a really brilliant bunch, and taking a peek under the hood can be equal parts awe-inspiring and cringy.</p>
<p>Today I wanted to highlight a heuristic that the HotSpot JVM uses for its various garbage collectors to reduce the amount of space it searches when performing a new-generation GC.</p>
<p>As a refresh: the JVM segregates the heap into multiple generations, the most notable being the YoungGen (or NewGen) and the OldGen. Objects in the YoungGen are expected to die young and thus be frequently available for collection, while the objects in OldGen are likely to stay in OldGen (rich get richer and poor get poorer is a decent analogy here).</p>
<p>When performing a GC for the YoungGen, the collector needs to find all “live” objects, and copy them somewhere, reclaiming the leftover space. Live objects are defined as follows:</p>
<ol type="1">
<li>All objects in the “root set”, consisting of objects referenced by stack references, or held by a static reference</li>
<li>All objects referenced in the field of another live object</li>
</ol>
<p>You can then construct the reachable set inductively, starting at the root set and iterating #2 until we’ve exhausted the tree of object references. For a minor GC, which only collects YoungGen, references to objects in OldGen are ignored for the purposes of creating this live tree, as in the minor GC we find all live YoungGen objects, copy/compact into a new space, and reclaim the rest as free space.</p>
<p>Ignoring Oldgen is risky though, because references to YoungGen objects can be held in OldGen! Think of a gigantic <code>ConcurrentHashMap</code> that you keep for the lifetime of your application, and you’ve just added a new entry to it. The map itself is in OldGen, and holds a reference to the newly added value that sits in YoungGen. To handle this, we need to perform <em>tracing</em> on assignments to reference fields in our objects. The question is how to do this tracing efficiently in such a way that it narrows our search space at collection time.</p>
<h3 id="enter-the-card-table">Enter the Card Table</h3>
<p>HotSpot maintains a <strong>card table</strong>, a structure that efficiently serves as a bitset for “dirty” memory pages. More concretely, say I have the following snippet of code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">// Somewhere inside some method...</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">this</span>.<span class="fu">myMap</span> = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;<span class="bu">String</span>, <span class="bu">String</span>&gt;();</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">// ...</span></a></code></pre></div>
<p>The JVM injects what is effectively the following code at runtime around the assignment:</p>
<pre><code>        CARD_TABLE[&amp;this &gt;&gt; 9] = 1</code></pre>
<p>Here, the mark bit for the address where the object resides is being set, meaning that there has been an assignment to a field in the card that holds this object, where a “card” here is a 2^9 = 512 byte region of the heap. We can now use the card table to form a heuristic over which objects in the OldGen need to be searched. Clearly, only objects in OldGen that exist in a card where their mark bit is set in the card table are eligible to hold new references to YoungGen objects. Thus, we augment our minor GC algorithm from before like so:</p>
<ol type="1">
<li>Start with root set as the set of all reachable objects</li>
<li>Transitively, find all objects in YoungGen reachable from the root set</li>
<li>Scan the card table, and for all cards in OldGen where the mark bit is set, scan objects in those cards for pointers to YoungGen</li>
<li>Clear the mark bits</li>
<li>After objects get relocated, update the pointers in OldGen, remarking cards in the card table if they actually point to YoungGen objects</li>
</ol>
<h3 id="links">Links</h3>
<p>A lot of this knowledge was gleaned from the following places, please go read these links to get more depth!</p>
<ul>
<li><a href="http://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots.html">“Understanding GC pauses in JVM, HotSpot’s minor GC”</a>. Card table stuff towards the beginning of the <em>Write Barrier</em> section.</li>
<li><a href="https://www.ibm.com/developerworks/library/j-jtp11253/">“Garbage collection in the HotSpot JVM”</a></li>
<li><a href="http://psy-lob-saw.blogspot.co.uk/2014/10/the-jvm-write-barrier-card-marking.html">“The JVM Write Barrier - Card Marking”</a></li>
<li><a href="https://blogs.oracle.com/dave/false-sharing-induced-by-card-table-marking">“False sharing induced by card table marking”</a></li>
<li><a href="http://www.memorymanagement.org/glossary/c.html#glossary-c">“Memory Management Reference”</a>, “C” section of the glossary. Checkout the definitions for <strong>card</strong> and <strong>card marking</strong>. Also this entire guide just looks pretty nice.</li>
</ul>


<hr />

<div>
    Like this post? Hate this post? <a href="https://twitter.com/intent/tweet?text=@andreweduffy+https://aduffy.io/posts/2018-02-13-card-tables.html+">Give me your feedback!</a>
</div>

      </div>
    </div>

    
  </body>
</html>
