<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <!-- <link href="https://fonts.googleapis.com/css?family=Roboto|Inconsolata|Work+Sans|Droid+Serif" rel="stylesheet"> -->
    <style>@font-face{font-family:'DroidSerif';font-style:normal;font-weight:400;src:local('DroidSerifRegular'),local('DroidSerif-Regular'),url(https://fonts.gstatic.com/s/droidserif/v8/tDbI2oqRg1oM3QBjjcaDkOr9rAA.ttf)format('truetype');}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;src:local('InconsolataRegular'),local('Inconsolata-Regular'),url(https://fonts.gstatic.com/s/inconsolata/v16/QldKNThLqRwH-OJ1UHjlKGlZ5q0.ttf)format('truetype');}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:local('Roboto'),local('Roboto-Regular'),url(https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxP.ttf)format('truetype');}@font-face{font-family:'WorkSans';font-style:normal;font-weight:400;src:local('WorkSans'),local('WorkSans-Regular'),url(https://fonts.gstatic.com/s/worksans/v3/QGYsz_wNahGAdqQ43Rh_fKDs.ttf)format('truetype');}</style>
    <!-- <link href="/css/text.css" rel="stylesheet" type="text/css"> -->
    <style>#header h1 { font-size: 120%; display: inline-block; } .sourceCode { overflow-x: scroll; } code, pre { color: #000; background-color: #fff; font-weight: normal; font-family: "Menlo", "Consolas", "Inconsolata", "Anonymous", "Monaco", monospace; font-size: 0.9em; line-height: 1.2em; } p code, li>code { border: 1px solid #DDDDDD; padding: 2px; font-size: 0.8em; } #header h1 a, h2.post-title a, h2.static-title a { color: #000; } ul, ol { margin-left: 2em; } div.highlight, pre { margin-bottom: 1em; } code.has-jax { border: none; background-color: #fff; } .date { font-style: italic; color: #4e4e4e; } body { font: 300 1.1em/1.6em Georgia, "Droid Serif", "Open Sans", "DejaVu Serif", serif; } blockquote { padding-top: 0; } .panel { padding-left: 2em; padding-right: 2em; font-size: 120%; } .panel p { font-weight: bold; font-style: italic; line-height: 1.1em; } footer { text-align: center; } footer span { font-style: italic; } footer { padding-top: 2em; } /* Generated by pandoc. */ table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; } td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; } td.sourceCode { padding-left: 5px; } .sourceCode span.kw { color: #007020; font-weight: bold; } .sourceCode span.dt { color: #902000; } .sourceCode span.dv { color: #40a070; } .sourceCode span.bn { color: #40a070; } .sourceCode span.fl { color: #40a070; } .sourceCode span.ch { color: #4070a0; } .sourceCode span.st { color: #4070a0; } .sourceCode span.co { color: #60a0b0; font-style: italic; } .sourceCode span.ot { color: #007020; } .sourceCode span.al { color: red; font-weight: bold; } .sourceCode span.fu { color: #06287e; } .sourceCode span.re { } .sourceCode span.er { color: red; font-weight: bold; }</style>
    <!-- <link href="/css/aduffy.css" rel="stylesheet" type="text/css"> -->
    <style>/* Modify selection color on WebKit/Mozilla. */ ::-moz-selection { background: antiquewhite; } ::selection { background: antiquewhite; } body { padding-bottom: 30px; }</style>
    
    <title>What's up, Meltdown? • aduffy.io</title>
    
  </head>
  <body>
    <div class="row">
        <div id="header" class="large-10 large-offset-1 columns">
            <h1><a href="../">aduffy.io</a>://</h1>
            <a href="../">posts</a>
            /
            <a href="../about.html">about</a>
            /
            <a href="../projects.html">projects</a>
            /
            <a href="../photos.html">photos</a>
            &mdash;
            <span><a class="underline" href="https://github.com/a10y/a10y.github.io/commit/5fb2127
">5fb2127
</a></span>
        </div>
    </div>
    <div class="row">
      <div class="large-10 large-centered columns">
        
        <h1>What's up, Meltdown?</h1>
        
        <p class="date">13 Jan 2018</p>

<p>Everyone seems to be going crazy about Meltdown/Spectre for the past week. I just finished reading <a href="https://meltdownattack.com/meltdown.pdf">the Meltdown paper</a>, and doing so made the existential threat clearer, though I’m still cautious to believe that the sky is falling. Very credible folks from the security community (tptacek et al.) seem to think that this is v bad, so I’m inclined to believe that I’m not seeing the full picture here.</p>
<p>I first read the Spectre PoC code (published in Appendix A of <a href="https://spectreattack.com/spectre.pdf">that paper</a> and available as in Github gist form <a href="https://gist.github.com/ErikAugust/724d4a969fb2c6ae1bbd7b2a9e3d4bb6">here</a>). I understand that Spectre is separate, but the two are related so I was hoping that the example code with shed some light on what everyone seemed so afraid of.</p>
<p>It turned out that the code mainly showcased poisoning the branch predictor to cause a speculative execution of an unintended memory read, but the PoC itself didn’t illustrate a huge hole in memory isolation as it effectively just uses the cache timing side-channel to read data out of a char array in user memory. Any process already has full access to all of its own user memory, so that wasn’t particularly interesting.</p>
<h3 id="what-the-authors-have-to-say">What the authors have to say</h3>
<p>The BLUF on Meltdown is that a malicious process can read any memory mapped into its address space using the cache timing side channel. Any process could already read arbitrary user memory, so what’s interesting here is that the attacker can also <strong>read kernel memory</strong> via timing reads via Flush+Reload (described in the paper section 5.1).</p>
<p>It seemed clear that with this mechanism, if the reads were performed quickly enough (and the authors claim speeds of ≥ 500KB/s) then you could read data from kernel buffers passed into syscalls by other processes, things like logins, etc. It was threatening, but you’d need then scan kernel memory for the buffer holding that data, <del>and at the advertised 500K/s it would take a day and a half to scan 1GB of kernel memory</del> <strong>EDIT: yea I messed up, it would only take about half an hour. This is much easier to mount.</strong> <del>Thus, feasible but limited.</del> However, my lack of understanding of something very basic about the Linux kernel is what prevented me from seeing what the big issue was—and this is the interesting part of the attack and why the IT industry have collectively curled up in fetal position since public disclosure.</p>
<h3 id="physmem-physmem-everywhere">Physmem, physmem everywhere</h3>
<p>On Linux (without KASLR) the kernel is mapped at some fixed address <code>KERNEL_START_ADDR</code>, specifically <code>0xffff880000000000</code> on 64-bit systems.</p>
<blockquote>
<p>Note: With KASLR 40 bits of entropy (the trailing 10 zeros) are added in, and the authors claim the starting point can be found in ≤ 128 steps.</p>
</blockquote>
<p>The Linux kernel, to make allocating pages easier, <strong>direct-maps all of physical memory into the kernel address space</strong> starting at the kernel offset. So for example, with KASLR enabled and a KASLR offset of <code>0xc000</code>, reading physical memory address <code>0x80000000</code> (the 2nd GiB of physical memory) would require the execution of a transient instruction reading from <code>0xffff88008000c000</code>.</p>
<p>This is huge. Up until now, address space isolation was one of the core tenets of Linux’s security model. Now by exploiting Meltdown, a single process could infer with high probability the values of bytes on arbitrary raw memory pages, which can be written by any process running on the system. Keep in mind though, at 500KB/s, one can scan an 8 gig machine in 11 days. It sounds to me like you need some information about which physical addresses are in use by a process to realistically execute this attack anywhere outside of the lab, but I’m sure there are ways of getting that information via side channels or the like.</p>
<h3 id="some-published-attacks">Some published attacks</h3>
<p>You’ll note that in <a href="https://www.youtube.com/watch?v=RbHbFkh6eeE">this video proof-of-concept</a> published by Michael Schwarz—one of the authors of the Meltdown paper—the following commandline is run to read in the text entered into a login screen:</p>
<pre><code>./reader 0x3c80e8040</code></pre>
<p>And the first line of output for the <code>reader</code> program is <code>0xffff8803c80e8040</code>.</p>
<p>Now we can probably guess that the attack is being mounted on a machine with KASLR enabled, and Michael is supplying the offset from <code>KERNEL_START_ADDR</code> where the kernel’s direct-physical mapping begins.</p>
<p>The code for runnign the PoC is available <a href="https://github.com/IAIK/meltdown/blob/master/README.md">on Github</a>, and the README is a great place to start reading about how they performed the exploits. In particular, it does in fact seem like you need to provide the physical address where your secrets from the other process are being stored to perform anything resembling the login screen attack shown in the video.</p>
<p>So, I get why things are bad, but I’m still not totally sure why the sky is falling. Any remotely interesting attack seems to need some significant extra information to be executed in a reasonable amount of time. Just food for thought!</p>


<hr />

<div>
    Like this post? Hate this post? <a href="https://twitter.com/intent/tweet?text=@andreweduffy+https://aduffy.io/posts/2018-01-13-meltdown.html+">Give me your feedback!</a>
</div>

      </div>
    </div>

    
  </body>
</html>
